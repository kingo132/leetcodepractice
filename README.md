# leetcodepractice
practice code of leetcode

* 99 ✅
* 468 ✅
* 706 ✅
* 105 ✅
* 79 ✅
* 135 ✅
* 569 ✅ SQL, Hard, Google, Checked the answer, can not remember
* 70 ✅
* 16 ✅
* 25 ✅
* 24 ✅
* =====
* 907 ✅ Checked the answer, not understand very well
* 328 ✅
* 547 ✅ 图遍历或并查集
* 36 ✅
* 694 锁定的题目，看了答案，没做
* 678 ✅
* 701 ✅
* 148 ✅
* 394 ✅
* 1483 ✅ 自己做的性能不行，看了答案
* 428 锁定的题目，看了答案
* 45 ✅
* 83 ✅
* 75
* 96 ✅
* 662 ✅
* 15 ✅ 效率太低，看了高效率的答案
* 86 ✅
* 862 ✅ hard，前缀和，单调双向队列
* ===== 20240610
* 743 ✅ Dijkstra算法
* 4 ✅ 归并排序，很简单
* 198 ✅ 动态规划
* ===== 20240611
* 142 ✅ 双指针 + Floyd’s Tortoise and Hare algorithm
* 116 ✅ 树的广度优先遍历
* 82 ✅ 链表删除重复节点
* 239 做过了
* 120 ✅ 动态规划也要分方向的，这道题要从下往上加，不能从上往下加
* 459 ✅ 答案有点trick
* 848 ✅ medium but should be easy
* 113 ✅ 树的后序非递归遍历，可以打印出树的path
* =====
* 39 ✅ 回溯
* 12 ✅
* 133 ✅ 图的邻接表的深度复制，需要非递归
* =====
* 700 ✅ 二叉树遍历，简单题
* 112 ✅ 树的路径和，简单题
* 46 ✅ 回溯，对全排列的枚举，可以通过不停交换元素实现
* 1356 ✅ 用内建qsort就很简单
* 69 ✅
* 171 ✅
* 128 ✅ 主要考验的是哈希表的实现的时间复杂度是否足够小，有很多实现细节需要考虑
* ===== 20240613
* 125 ✅
* 426 锁住了
* 445 ✅
* 189 ✅ 树组移位的可以用反转整个树组和局部树组来实现
* 162 ✅ 看到O(log n)就一定是二分搜索
* 221 ✅ 典型的动态规划问题，感觉解法只能背，或者猜，动态规划算法怎么设计得好好研究一下
* ===== 20240614
* 973 ✅ 1: 最大堆求最小前k个，最小堆求最大前k个, 2: 堆的向下堆化才能保证数组的元素有序排列，向上堆化无法保证
* 307 线段树，晚点再做 ⚠️
* ===== 20240615
* 227 ✅ 表达式求值，中缀转后缀等算法，注意一些细节不要搞错
* 617 ✅
* 912 ✅ 可以用 merge sort 或者 heap sort，但是没用下次有时间再练⚠️，用了稍微做了点优化的快排：小于10用简单排序，随机pivot
* 37 ✅ 数独问题，回溯
* 232 ✅ 双栈模拟队列，不是很对，但以后再说吧
* 155 ✅
* ===== 20240616
* 2 ✅
* 47 ✅ 全排列，两种：交换或者枚举坐标
* 767 ✅
* 11 ✅
* 169 ✅ 摩尔投票算法
* ===== 20240617
* 1155 ✅ 掷骰子，动态规划
* 692 ✅ 前k大，最小堆问题
* 91 ✅ 典型动态规划问题
* 407 ✅ Hard，看了chatgpt答案，每次从最小的高度（最小堆）开始向外传播。还有一种思想，如果计算上下左右循环依赖，通常都是用（优先）队列和图的广度优先搜索，或递归。
* ===== 20240618
* 100 ✅ 简单题，树遍历
* 739 ✅ 如果不知道怎么做，先写出穷举算法，然后再想办法减少搜索次数。
* ===== 20240619
* 101 ✅ 简单题，树遍历
* 222 ✅ 简单题，树遍历
* 400 ✅ 可以用数学公式，基本上都是在公式的0，1边界耗费很多时间
* 225 双队列实现栈，做过了
* 628 ✅ 排序以后就很好做
* 111 ✅ 简单题，树遍历
* 150 ✅ 逆波兰/后缀表达式，求值
* 191 ✅ 简单题，汉明权重，1bit的个数
* 1013 ✅ 用2个坐标指针
* 200 ✅ 几个岛屿问题，图的遍历
* ===== 20240620
* 61 ✅ 链表shift
* 1497 ✅ 做得太复杂，看了ChatGPT的答案，对于整除问题，可以多利用余数来做
* 44 ✅ 通配符匹配的动态规划算法，穷举+记录中间结果
* ===== 20240621
* 26 ✅ 数组去重，双指针简单题
* 3 ✅ 数组或字符串的坐标或指针容易绕进去，解决办法就是静下心来仔细一边思考一边写代码，但是对于复杂的情况如果脑子思考不过来，也只能一点一点思考，如果不停用测试用例试那会越来越乱
* 362 隐藏题目
* 415 ✅ 字符串数字相加，简单题
* 63 ✅ 对于需要知道后面的数据来累加的递归，可以改成反向的动态规划。对于动态规划问题，可以先试着用一个数组来凑一凑看看能不能实现。
* 10 跟44题一样的
* 19 ✅ 链表双指针问题，加dummyHead
* ===== 20240622
* 679 ✅ 数组和运算符枚举，可以两两枚举，然后递归继续两两枚举。当然也可以二分的方式递归，感觉两两简单一些。
* 440 ✅ n叉树先序遍历的第m步。Hard题。看了答案，不是很熟练，下次再练吧⚠️
* ===== 20240626
* 62 ✅ 图的路径条数，典型动态规划问题
* 516 ✅ 搜索空间巨大的，大概率要动态规划，能记录中间值，就记录中间值。尽量用数组或矩阵记录中间值，最差用哈希记录中间值。
* 124 ✅ 树的最长路径和，分治。
* ===== 20240627
* 556 ✅ 整数变换位置求最小
* 470 ✅ 随机数，平均概率放大
* 42 ✅
* ===== 20240628
* 199 ✅
* 210 ✅ 拓扑排序，可以把有向图方向反转以后用后根遍历，但是要在搜索时加上标记，用来检查是否遇到换，另外对结果要验证看是否漏掉了节点。但是经典拓扑是根据入度来遍历的。
* 611 ✅ 排序以后二分搜索。二分搜索在最后的l和r的时候要仔细处理。
* 344 ✅ 字符串反转，简单题
* 1004 ✅
* 13 ✅ 罗马数字和整数互相变换
* 206 ✅ 链表反序，一个节点一个节点反序
* 110 ✅ 判断是否是平衡二叉树
* 94 ✅ 树的中序遍历
* 6 ✅ 通过列出前几种case找出规律
* ===== 20240629
* 93 ✅ IP地址合法性校验
* 121 ✅ 数组最大最小值问题，简单题
* 164 ✅ 基数排序和计数排序
* 207 ✅ 拓扑排序，用入度数组来计算
* 8 ✅ 实现atoi
* 384 ✅ 数组全排列问题，用了交换元素实现
* 670 ✅ 选择排序的变种。这种问题，在等号处理的地方要格外小心，有些特例就是用来检验等号处理的。
* 168 ✅ Excel表的标题符号，相当于一个26进制的数字，注意这个数字没有0，需要特别处理一下。
* ===== 20240630
* 14 ✅ 字符串最长前缀，简单题
* 867 ✅ 数组转置，简单题，交换一下i和j坐标就可以了，然后数组大小
* 74 ✅ 二分搜索矩阵，注意防止死循环，简单
* 56 ✅ 数组排序后合并，如果不写排序的话不是很难，注意指针的操作细节，不要搞乱绕进去
* 509 ✅ 斐波那契数列，简单题
* 51 ✅ 八皇后问题，难点在于：1. 对角线坐标的判断；2. 循环的构造及递归的构造
* 104 ✅ 树的高度，简单题
* 863 ✅ 树图遍历
* 88 ✅ 数组插入排序合并，简单题
* 347 ✅ 数字频率：哈希，前k大：最小堆
* ===== 20240702
* 7 ✅ 整数反转，考虑最大最小值溢出等问题
* 718 ✅ 数组最长公共字串，边界坐标处理要小心。对于二分递归问题，也可以左右各循环一遍解决。如果超时，一定要想尽办法减少搜索次数，通过各种判断或者坐标移动限制，减少次数。本题其实是动态规划题，如果为了避免重复计算，那肯定就是动态规划了，当然左右各循环一遍，也可以用动态规划的数组保存中间结果。所以，减少搜索次数只有两种：1 动态规划避免重复计算，2 剪枝，避免不必要计算。
* 797 ✅ 图的深度和广度优先遍历，并记录所有路径
* 386 ✅ 字典序10叉树的深度优先遍历
* ===== 20240703
* 713 ✅ 字序列个数的计算是个麻烦的问题
* 41 ✅ 对于前n个正整数的计数，除了可以用哈希，还要学会利用原数组，把它们摆到对应数字的位置上
* ===== 20240704
* 1143 ✅ 动态规划的dp矩阵，矩阵的计算方式，可以通过自己用几个例子画表格的方式凑出来
* 146 ✅ LRU，哈希表和双向链表，链表的指针很容易出错，尤其是双向的，一定要小心。可以考虑把链表操作做成单独的函数，以减少出错概率。
* ===== 20240705
* 73 ✅ 利用原本矩阵里的空间，减少新分配的空间
* ===== 20240706
* 1358 ✅ 善于利用辅助树组，减少计算次数，尤其是会有很多重复计算的循环。
* 138 ✅ 多利用原链表的指针，甚至可以强行潜入新数据，然后后面再复原回去。
* 242 ✅ 简单题
* 154 ✅ 二分搜索可以用在rotated sorted array
* 59 ✅ 螺旋矩阵，用left,right,top,bottom四个索引更简单方便
* 173 ✅ 二叉树的中序遍历Iterator，用一个辅助堆栈来实现
* 1314 ✅ 矩阵窗口求和，通过滑动窗口避免重复计算
* 268 ✅ 原数组利用+整数当数组索引
* 151 做过了
* ===== 20240707
* 1312 ✅ 遇到多重选择就递归，遇到递归就看能不能动态规划优化
* 337 ✅ 树的递归动态规划问题。注意⚠️可以通过子函数返回多个数据，来减少递归的次数，防止超时。
* 208 ✅ 前缀树：自动补全，拼写检查
* 460 ✅ ⚠️哈希表要比实际稍微大一点，大概2～3倍，否则容易超时！！⚠️双向链表移动太难了，得想想怎么处理双向链表的问题。试试把双向链表做成函数，然后重写代码。
* ===== 20240709
* 102 ✅ 树的广度优先遍历
* 9 ✅ 回文数判断，简单题
* 1615 ✅ 图的邻接矩阵遍历，不是很麻烦
* 752 ✅ 回溯 + 动态规划 + 利用矩阵避免搜索数组
* 137 ❌ 位操作，看了答案看不懂，先放着
* 122 ✅ 股票买卖题，相对简单
* ===== 20240710
* 17 ✅ 枚举，用图的广度优先遍历
* 329 ✅ 最长路径，动态规划，DFS深度优先遍历+记忆
* 72 ✅ 字符串编辑距离，动态规划题
* 673 ✅ 动态规划 + 记录最长序列的次数，两个动态规划的数组
* ===== 20240711
* 543 ✅ 树的直径，简单题
* 450 ✅ 二叉树删除节点，注意⚠️要背下来。
* 236 ✅ 节点的最小公共祖先，递归就行了
* 572 ✅ 判断是否有相同子树
* 224 ✅ 计算器字符串解析问题，双堆栈再考虑运算符优先级，不是很难，注意最好背下解法
* ===== 20240712
* 123 ✅ 左右分别计算，效率比动态规划高
* 152 ✅
* ===== 20240713
* 84 ✅ 单调栈，专门用来解决：直方图里的最大矩阵问题。
* 887 ✅ 鸡蛋掉落破碎问题，困难题，看了答案，下次再自己写吧
* 52
* 449
* 64
* 53
* 134
* 695
* 1375
* 23
* 353
* 704
* 145
* 98
* 114
* 785
* 877
* 240
* 643
* 1095
* 22
* 1570
* 165
* 31
* 503
* 166
* 103
* 287
* 297
* 54
* 55
* 34
* 230
* 311
* 295
* 78
* 1
* 300
* 97
* 141
* 20
* 234
* 560
* 48
* 557
* 89
* 71
* 518
* 986
* 33
* 109
* 283
* 50
* 139
* 21
* 60
* 958
* 442
* 40
* 322
* 76
* 213
* 443
* 871
* 209
* 85
* 349
* 226
* 136
* 129
* 119
* 844
* 402
* 354
* 106
* 498
* 29
* 43
* 144
* 215
* 160
* 179
* 1047
* 153
* 513
* 5
