# leetcodepractice
practice code of leetcode

* 99 ✅
* 468 ✅
* 706 ✅
* 105 ✅
* 79 ✅
* 135 ✅
* 569 ✅ SQL, Hard, Google, Checked the answer, can not remember
* 70 ✅
* 16 ✅
* 25 ✅
* 24 ✅
* =====
* 907 ✅ Checked the answer, not understand very well
* 328 ✅
* 547 ✅ 图遍历或并查集
* 36 ✅
* 694 锁定的题目，看了答案，没做
* 678 ✅
* 701 ✅
* 148 ✅
* 394 ✅
* 1483 ✅ 自己做的性能不行，看了答案
* 428 锁定的题目，看了答案
* 45 ✅
* 83 ✅
* 75
* 96 ✅
* 662 ✅
* 15 ✅ 效率太低，看了高效率的答案
* 86 ✅
* 862 ✅ hard，前缀和，单调双向队列
* ===== 20240610
* 743 ✅ Dijkstra算法
* 4 ✅ 归并排序，很简单
* 198 ✅ 动态规划
* ===== 20240611
* 142 ✅ 双指针 + Floyd’s Tortoise and Hare algorithm
* 116 ✅ 树的广度优先遍历
* 82 ✅ 链表删除重复节点
* 239 做过了
* 120 ✅ 动态规划也要分方向的，这道题要从下往上加，不能从上往下加
* 459 ✅ 答案有点trick
* 848 ✅ medium but should be easy
* 113 ✅ 树的后序非递归遍历，可以打印出树的path
* =====
* 39 ✅ 回溯
* 12 ✅
* 133 ✅ 图的邻接表的深度复制，需要非递归
* =====
* 700 ✅ 二叉树遍历，简单题
* 112 ✅ 树的路径和，简单题
* 46 ✅ 回溯，对全排列的枚举，可以通过不停交换元素实现
* 1356 ✅ 用内建qsort就很简单
* 69 ✅
* 171 ✅
* 128 ✅ 主要考验的是哈希表的实现的时间复杂度是否足够小，有很多实现细节需要考虑
* ===== 20240613
* 125 ✅
* 426 锁住了
* 445 ✅
* 189 ✅ 树组移位的可以用反转整个树组和局部树组来实现
* 162 ✅ 看到O(log n)就一定是二分搜索
* 221 ✅ 典型的动态规划问题，感觉解法只能背，或者猜，动态规划算法怎么设计得好好研究一下
* ===== 20240614
* 973 ✅ 1: 最大堆求最小前k个，最小堆求最大前k个, 2: 堆的向下堆化才能保证数组的元素有序排列，向上堆化无法保证
* 307 线段树，晚点再做 ⚠️
* ===== 20240615
* 227 ✅ 表达式求值，中缀转后缀等算法，注意一些细节不要搞错
* 617 ✅
* 912 ✅ 可以用 merge sort 或者 heap sort，但是没用下次有时间再练⚠️，用了稍微做了点优化的快排：小于10用简单排序，随机pivot
* 37 ✅ 数独问题，回溯
* 232 ✅ 双栈模拟队列，不是很对，但以后再说吧
* 155 ✅
* ===== 20240616
* 2 ✅
* 47 ✅ 全排列，两种：交换或者枚举坐标
* 767 ✅
* 11 ✅
* 169 ✅ 摩尔投票算法
* ===== 20240617
* 1155 ✅ 掷骰子，动态规划
* 692 ✅ 前k大，最小堆问题
* 91 ✅ 典型动态规划问题
* 407 ✅ Hard，看了chatgpt答案，每次从最小的高度（最小堆）开始向外传播。还有一种思想，如果计算上下左右循环依赖，通常都是用（优先）队列和图的广度优先搜索，或递归。
* ===== 20240618
* 100 ✅ 简单题，树遍历
* 739 ✅ 如果不知道怎么做，先写出穷举算法，然后再想办法减少搜索次数。
* ===== 20240619
* 101 ✅ 简单题，树遍历
* 222 ✅ 简单题，树遍历
* 400 ✅ 可以用数学公式，基本上都是在公式的0，1边界耗费很多时间
* 225 双队列实现栈，做过了
* 628 ✅ 排序以后就很好做
* 111 ✅ 简单题，树遍历
* 150 ✅ 逆波兰/后缀表达式，求值
* 191 ✅ 简单题，汉明权重，1bit的个数
* 1013 ✅ 用2个坐标指针
* 200 ✅ 几个岛屿问题，图的遍历
* ===== 20240620
* 61 ✅ 链表shift
* 1497 ✅ 做得太复杂，看了ChatGPT的答案，对于整除问题，可以多利用余数来做
* 44 ✅ 通配符匹配的动态规划算法，穷举+记录中间结果
* ===== 20240621
* 26 ✅ 数组去重，双指针简单题
* 3 ✅ 数组或字符串的坐标或指针容易绕进去，解决办法就是静下心来仔细一边思考一边写代码，但是对于复杂的情况如果脑子思考不过来，也只能一点一点思考，如果不停用测试用例试那会越来越乱
* 362 隐藏题目
* 415 ✅ 字符串数字相加，简单题
* 63 ✅ 对于需要知道后面的数据来累加的递归，可以改成反向的动态规划。对于动态规划问题，可以先试着用一个数组来凑一凑看看能不能实现。
* 10 跟44题一样的
* 19 ✅ 链表双指针问题，加dummyHead
* ===== 20240622
* 679 ✅ 数组和运算符枚举，可以两两枚举，然后递归继续两两枚举。当然也可以二分的方式递归，感觉两两简单一些。
* 440 ✅ n叉树先序遍历的第m步。Hard题。看了答案，不是很熟练，下次再练吧⚠️
* ===== 20240626
* 62 ✅ 图的路径条数，典型动态规划问题
* 516 ✅ 搜索空间巨大的，大概率要动态规划，能记录中间值，就记录中间值。尽量用数组或矩阵记录中间值，最差用哈希记录中间值。
* 124 ✅ 树的最长路径和，分治。
* ===== 20240627
* 556 ✅ 整数变换位置求最小
* 470 ✅ 随机数，平均概率放大
* 42 ✅
* ===== 20240628
* 199 ✅
* 210 ✅ 拓扑排序，可以把有向图方向反转以后用后根遍历，但是要在搜索时加上标记，用来检查是否遇到换，另外对结果要验证看是否漏掉了节点。但是经典拓扑是根据入度来遍历的。
* 611 ✅ 排序以后二分搜索。二分搜索在最后的l和r的时候要仔细处理。
* 344 ✅ 字符串反转，简单题
* 1004 ✅
* 13 ✅ 罗马数字和整数互相变换
* 206 ✅ 链表反序，一个节点一个节点反序
* 110 ✅ 判断是否是平衡二叉树
* 94 ✅ 树的中序遍历
* 6 ✅ 通过列出前几种case找出规律
* ===== 20240629
* 93 ✅ IP地址合法性校验
* 121 ✅ 数组最大最小值问题，简单题
* 164 ✅ 基数排序和计数排序
* 207 ✅ 拓扑排序，用入度数组来计算
* 8 ✅ 实现atoi
* 384 ✅ 数组全排列问题，用了交换元素实现
* 670 ✅ 选择排序的变种。这种问题，在等号处理的地方要格外小心，有些特例就是用来检验等号处理的。
* 168 ✅ Excel表的标题符号，相当于一个26进制的数字，注意这个数字没有0，需要特别处理一下。
* ===== 20240630
* 14 ✅ 字符串最长前缀，简单题
* 867 ✅ 数组转置，简单题，交换一下i和j坐标就可以了，然后数组大小
* 74 ✅ 二分搜索矩阵，注意防止死循环，简单
* 56 ✅ 数组排序后合并，如果不写排序的话不是很难，注意指针的操作细节，不要搞乱绕进去
* 509 ✅ 斐波那契数列，简单题
* 51 ✅ 八皇后问题，难点在于：1. 对角线坐标的判断；2. 循环的构造及递归的构造
* 104 ✅ 树的高度，简单题
* 863 ✅ 树图遍历
* 88 ✅ 数组插入排序合并，简单题
* 347 ✅ 数字频率：哈希，前k大：最小堆
* ===== 20240702
* 7 ✅ 整数反转，考虑最大最小值溢出等问题
* 718 ✅ 数组最长公共字串，边界坐标处理要小心。对于二分递归问题，也可以左右各循环一遍解决。如果超时，一定要想尽办法减少搜索次数，通过各种判断或者坐标移动限制，减少次数。本题其实是动态规划题，如果为了避免重复计算，那肯定就是动态规划了，当然左右各循环一遍，也可以用动态规划的数组保存中间结果。所以，减少搜索次数只有两种：1 动态规划避免重复计算，2 剪枝，避免不必要计算。
* 797 ✅ 图的深度和广度优先遍历，并记录所有路径
* 386 ✅ 字典序10叉树的深度优先遍历
* ===== 20240703
* 713 ✅ 字序列个数的计算是个麻烦的问题
* 41 ✅ 对于前n个正整数的计数，除了可以用哈希，还要学会利用原数组，把它们摆到对应数字的位置上
* ===== 20240704
* 1143 ✅ 动态规划的dp矩阵，矩阵的计算方式，可以通过自己用几个例子画表格的方式凑出来
* 146 ✅ LRU，哈希表和双向链表，链表的指针很容易出错，尤其是双向的，一定要小心。可以考虑把链表操作做成单独的函数，以减少出错概率。
* ===== 20240705
* 73 ✅ 利用原本矩阵里的空间，减少新分配的空间
* ===== 20240706
* 1358 ✅ 善于利用辅助树组，减少计算次数，尤其是会有很多重复计算的循环。
* 138 ✅ 多利用原链表的指针，甚至可以强行潜入新数据，然后后面再复原回去。
* 242 ✅ 简单题
* 154 ✅ 二分搜索可以用在rotated sorted array
* 59 ✅ 螺旋矩阵，用left,right,top,bottom四个索引更简单方便
* 173 ✅ 二叉树的中序遍历Iterator，用一个辅助堆栈来实现
* 1314 ✅ 矩阵窗口求和，通过滑动窗口避免重复计算
* 268 ✅ 原数组利用+整数当数组索引
* 151 做过了
* ===== 20240707
* 1312 ✅ 遇到多重选择就递归，遇到递归就看能不能动态规划优化
* 337 ✅ 树的递归动态规划问题。注意⚠️可以通过子函数返回多个数据，来减少递归的次数，防止超时。
* 208 ✅ 前缀树：自动补全，拼写检查
* 460 ✅ ⚠️哈希表要比实际稍微大一点，大概2～3倍，否则容易超时！！⚠️双向链表移动太难了，得想想怎么处理双向链表的问题。试试把双向链表做成函数，然后重写代码。
* ===== 20240709
* 102 ✅ 树的广度优先遍历
* 9 ✅ 回文数判断，简单题
* 1615 ✅ 图的邻接矩阵遍历，不是很麻烦
* 752 ✅ 回溯 + 动态规划 + 利用矩阵避免搜索数组
* 137 ❌ 位操作，看了答案看不懂，先放着
* 122 ✅ 股票买卖题，相对简单
* ===== 20240710
* 17 ✅ 枚举，用图的广度优先遍历
* 329 ✅ 最长路径，动态规划，DFS深度优先遍历+记忆
* 72 ✅ 字符串编辑距离，动态规划题
* 673 ✅ 动态规划 + 记录最长序列的次数，两个动态规划的数组
* ===== 20240711
* 543 ✅ 树的直径，简单题
* 450 ✅ 二叉树删除节点，注意⚠️要背下来。
* 236 ✅ 节点的最小公共祖先，递归就行了
* 572 ✅ 判断是否有相同子树
* 224 ✅ 计算器字符串解析问题，双堆栈再考虑运算符优先级，不是很难，注意最好背下解法
* ===== 20240712
* 123 ✅ 左右分别计算，效率比动态规划高
* 152 ✅
* ===== 20240713
* 84 ✅ 单调栈，专门用来解决：直方图里的最大矩阵问题。
* 887 ✅ 鸡蛋掉落破碎问题，困难题，看了答案，下次再自己写吧
* 52 ✅ N皇后问题，回溯，不难的
* ===== 20240714
* 449 ✅ 二叉树的序列化和反序列化，如果是全叉树存储，那么一次前序遍历就可以了。
* 64 ✅ 矩阵最短路径和，典型动态规划问题，递归就可以
* 53 ✅ 最大子序列和，典型的Kadane’s Algorithm
* 134 ✅ 看了ChatGPT答案，大概需要记住算法吧
* 695 ✅ 最大岛屿大小，典型回溯
* 1375 ✅
* 23 ✅
* 353 ❓锁住了
* 704 ✅ 二分搜索，简单题
* 145 ✅ 树的后序遍历，简单题
* 98 ✅ 二叉树验证
* 114 ✅ 二叉树压扁，需要小心保存老的值
* ===== 20240715
* 785 ✅
* 877 ✅ 1. 动态规划算法一定要先从大到小问题的思路去思考；2. 动态规划一定要减少每次迭代的参数个数；3. 动态规划要存储每个迭代的参数不能遗漏。
* ===== 20240716
* 240 ✅ 一种斜方向的递增矩阵，应该从右上角或者左下角开始搜索，否则复杂度就很高，两个搜索方向的递增顺序必须相反！！
* 643 ✅ 数组滑动窗口，简单题
* 1095 ✅ 对于山峰数组（中间高两边低），先找到peak，然后左右分别二分搜索
* 22 ✅ 括号配对的枚举，用回溯法
* 1570 ❓锁住了
* 165 ✅ 字符串数字解析
* 31 ✅ 数组的字典序枚举
* 503 ✅ 向右找第一个最大值，对于这种遍历不能用最大最小值带过来的，一般都要考虑用单调栈！
* ===== 20240718
* 166 ✅ 小数转字符串并且要找到循环小数，有点麻烦
* 103 ✅ 层序遍历二叉树，然后反转其中一些数组
* 287 ✅ 快慢指针可以用来寻找数组里的重复元素
* ===== 20240719
* 297 ✅ 二叉树的序列化和反序列化，大概背住算法就行了
* 54 ✅ 矩阵的螺旋访问
* 55 ✅
* ===== 20240721
* 34 ✅ 应该用二分法查找的，但是暴力搜索也通过了
* 230 ✅ 二叉树遍历
* 311 ❓锁住了
* 295 ✅ 1. 插入和找到median最高效的就是两个heap对接；2. 最大堆排序得到升序；3. 插入，向上堆化，再向下堆化，无法保证数组有序；要替换堆顶，然后向下堆化，才能保证有序。
* 78 ✅ 枚举用交换元素；子集用每次增加元素；
* 1 ✅ 简单题
* ===== 20240722
* 300 ✅ 动态规划
* 97 ✅ 动态规划。注意⚠️动态规划每一个函数内不需要考虑其他数组元素的值存储，只需要考虑自己的就可以了，但是return前必须要把自己的值存下来
* 141 ✅ 简单题，链表判断循环
* 20 ✅ 堆栈括号的判断，简单题
* 234 ✅ 链表palindrome的判断
* 560 ✅ 前缀和+哈希+一个需要记住的算法
* ===== 20240723
* 48 ✅ 图像旋转，讨厌的数组坐标计算，很烦的。先转置，在每行反转，会简单很多。
* 557 ✅ 字符串反转，简单题
* 89 ✅ 格雷码，固定算法：镜射排列。记住就行了。
* 71 ✅ 路径字符串精简，不是很难，用python就更简单
* ===== 20240724
* 518 ✅ 动态规划题
* 986 ✅ 线段重叠的判断，注意一下边界，一次遍历就可以了
* 33 ✅ 二分搜索，注意边界，可以自己写一些测试用例来调试吗？？面试的时候不可能用例子来修正代码的。
* 109 ✅ 有序链表转平衡二叉树，二分构造，不是很难
* 283 ✅ 数组移动0，简单题
* 50 ✅ 实现pow
* 139 ✅ 字符串拆分，动态规划题
* 21 ✅ 合并有序链表，简单题
* 60 ✅ 数组的全排列。⚠️把递归和非递归的代码全部背下来！！！
* 958 ✅ 判断完全二叉树，记住算法就行了。
* ===== 20240725
* 442 ✅ 数组里查找重复元素，把数字移到它该存在的坐标，这样遍历一次就行了。
* 40 ✅ 回溯/动态规划对于：取还是不去的选择，要用for循环来做。就像这一题，必须要用for循环才比较方便。
* 322 ✅ 1. 尽可能简化dp数组的大小，这里每次从1到n遍历，就不需要再保存这个角标这一维度了 2. DP算法优化的终极状态，就是只累积计算DP数组。慢慢研究，总能把dp数组直接计算规则整理出来的。
* 76 ✅ 字符串数组，可以灵活利用26个字母的数组当哈希表
* 213 ✅ 多练习动态规划怎么存储，这里很需要技巧，整个动态规划结构调整不好，存储就很麻烦很容易出错。
* ===== 20240726
* 443 ✅ 字符串的处理，数组索引处理要格外小心，多仔细思考。
* 871 ✅ 加油站加油次数问题，动态规划，记住chatgpt的答案就行了。
* 209 ✅ 子数组和等于多少的问题，因为没有负数，前缀和+滑动窗口就行了
* 85
* 349
* 226
* 136
* 129
* 119
* 844
* 402
* 354
* 106
* 498
* =====
* 29
* 43
* 144
* 215
* 160
* 179
* 1047
* 153
* 513
* 5
